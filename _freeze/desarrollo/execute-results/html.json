{
  "hash": "8cfda6e74c730317d5c49b3f3b1bab31",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Desarrollo integral de las ecuaciones y modelos de regresión\"\nformat: \n  html:\n    number-sections: true\n    toc: true\n    embed-resources: true\n    crossrefs-hover: false\n    css: style.css\n    code-copy: true\n    lang: es\n    bibliography: bibliografia/bibliografia.bib\n    csl: bibliografia/ieee.csl\n    cap-location: bottom\n---\n\n\n\n\n\n# Revisión bibliográfica\n\nEsta revisión tiene como objetivo identificar los enfoques más comunes en la literatura, los tipos de datos utilizados y las variables espectrales que se consideran más relevantes para este tipo de estimaciones.\n\n## Profundidad de disco de Secchi\n\nLa profundidad de visibilidad del disco de Secchi $(SDD)$ es una medida ampliamente utilizada para evaluar la transparencia del agua. Se define como la profundidad en metros a la cual un disco blanco circular desaparece al dejarlo descender en un cuerpo de agua.\n\nEsta variable es un indicador indirecto de la calidad del agua, ya que se relaciona con la concentración de sedimentos en suspensión, fitoplancton y otros materiales particulados. Continua siendo utilizado debido a la simplicidad y rango de aplicación universal del método, además de tratarse de un parámetro fácilmente entendible por el público.\n\n## Métodos tradicionales de estimación\n\nEn las últimas décadas, se han desarrollado múltiples ecuaciones empíricas y modelos basados en datos in situ y sensores remotos para estimar esta profundidad de manera eficiente y a gran escala. El objetivo de recopilar es identificar patrones comunes, variables predictoras relevantes y estrategias metodológicas empleadas.\n\n| Nombre                 | Variable           | Formula                                 | Muestras | R²   |\n|------------------------|--------------------|-----------------------------------------|----------|------|\n| Dekker and Peters      | $\\mathrm{ln(SDD)}$ | $\\mathrm{ln(Red)}$                      | 15       | 0.86 |\n| Dominguez Gomez et al. | $\\mathrm{SDD}$     | $\\mathrm{(Green)^x}$                    | 16       | 0.90 |\n| Giardino et al.        | $\\mathrm{SDD}$     | $\\mathrm{Blue/Green}$                   | 4        | 0.85 |\n| Kloiber et al.         | $\\mathrm{ln(SDD)}$ | $\\mathrm{Blue/Red + Blue}$              | 374      | 0.93 |\n| Lathrop and Lillesand  | $\\mathrm{ln(SDD)}$ | $\\mathrm{Green}$                        | 9        | 0.98 |\n| Mancino et al.         | $\\mathrm{SDD}$     | $\\mathrm{Red/Green + Blue/Green + Blue}$| 60       | 0.82 |\n\n\n: Tabla 1: Algoritmos publicados para la predicción de $\\mathrm{SDD}$ utilizando la plataforma Landstat @Rubin. {.striped .hover .responsive}\n\nEn la mayoría de los casos la relación entre $SDD$ y la intensidad de la luz es no lineal, por lo que se utiliza $ln(SDD)$ para realizar la regresión.\n\nLa correlación con la banda roja puede explicarse causalmente por la correlación positiva directa entre la reflectancia en el rojo y la carga bruta de partículas que induce la dispersión de partículas. De manera que mientras que la claridad del agua $(SDD)$ desciende, la intensidad en el rojo aumenta @Matthews.\n\nComo referencia se presentan las propiedades de las distintas bandas de la plataforma espacial Sentinel-2:\n\n|  |  | Sentinel-2A | | Sentinel-2B | |\n|:--|--:|--:|--:|--:|--:|\n| **Banda** | **Resolución espacial (m)** | **Longitud de onda (nm)** | **Ancho de banda (nm)** | **Longitud de onda (nm)** | **Ancho de banda (nm)** |\n| $\\mathrm{B01}$ (aerosol) | 60 | 442.7 | 20 | 442.3 | 20 |\n| $\\mathrm{B02}$ (blue) | 10 | 492.7 | 65 | 492.3 | 65 |\n| $\\mathrm{B03}$ (green) | 10 | 559.8 | 35 | 558.9 | 35 |\n| $\\mathrm{B04}$ (red) | 10 | 664.6 | 38 | 664.9 | 31 |\n| $\\mathrm{B05}$ (red edge) | 20 | 794.1 | 14 | 703.8 | 15 |\n| $\\mathrm{B06}$ | 20 | 748.5 | 14 | 739.1 | 13 |\n| $\\mathrm{B07}$ | 20 | 782.8 | 19 | 779.7 | 19 |\n| $\\mathrm{B08}$ (NIR) | 10 | 832.8 | 105 | 832.9 | 104 |\n| $\\mathrm{B8A}$ | 20 | 864.7 | 21 | 864.0 | 21 |\n| $\\mathrm{B09}$ | 60 | 945.1 | 19 | 943.2 | 20 |\n| $\\mathrm{B10}$ | 60 | 1373.5 | 29 | 1376.9 | 29 |\n| $\\mathrm{B11}$ (SWIR 1) | 20 | 1613.7 | 90 | 1616.4 | 94 |\n| $\\mathrm{B12}$ (SWIR 2) | 20 | 2292.4 | 174 | 2185.7 | 184 |\n\n: Tabla 2: Propiedades de las bandas S2-MSI, para las plataformas S2A y S2B. {.striped .hover .responsive tbl-colwidths=\"[20,20,15,15,15,15]\"}\n\n## Regresión lineal\n\nEn estadística, la regresión lineal es un modelo matemático usado para aproximar la relación de dependencia entre una variable dependiente $Y$ con $m$ variables independientes $X_i$. Este modelo puede ser expresado como:\n\n$$ Y = \\beta_0 +  \\beta_1 X_1 + \\cdots + \\beta_m X_m$$\n\ndonde:\n\n- $Y$ es la variable dependiente o variable de respuesta.\n- $X_1,X_2,...X_m$ son las variables explicativas, independientes o regresoras.\n- $\\beta_0,\\beta_1,\\beta_2,...\\beta_m$ son los parámetros del modelo, miden la influencia que las variables explicativas tienen sobre el regrediendo.\n\n### Selección de variables\n\nLa seleccion de variables y características es el foco de mucha investigación. El objetivo de la selección de variables es mejorar el rendimiento de predicción de los predictores y proporcionar una mejor comprensión del proceso subyacente que generó los datos. \n\nLa identificación de las variables más relevantes para incluir o excluir en un modelo predictivo es un paso fundamental en cualquier investigación rigurosa, especialmente cuando se busca construir modelos con alto poder explicativo y capacidad de generalización. \n\nComprender qué variables contribuyen en mayor medida a la calidad de las predicciones permite no solo mejorar el desempeño del modelo, sino también interpretar con mayor claridad los fenómenos que se están estudiando.\n\nNo existe una forma segura de definir la importancia de una variable puesto que la utilidad de la misma depende del modelo implementado y de las demás variables con las que interactua: una variable que es completamente inutil por si misma puede resultar en una mejora del rendimiento significativa cuando es considerada junto con otras variables @guyon2003introduction. \n\nA pesar de las dificultades existen estrategias útiles para determinar un subconjunto de variables útiles para la predicción. Tal es el caso de los métodos *forward selection* y *backwards elimination*. En *forward selection*, las variables son progresivamente incorporadas, evaluando el modelo al paso de cada una, mientras que en *backwards elimination* uno empieza con el conjunto entero de variables y progresivamente elimina las menos prometedoras.\n\nUna forma de implementación de *forward selection* es por empezar por un modelo exento de variables independientes, pero cuyo término independiente sea la media de las variables de respuesta. A partir de este valor se calcula el residuo como la diferencia entre el valor verdadero $Y$ y el valor predecido $Y_{pred}$.\n\n$$r = Y - Y_{pred}$$\n\nSeguidamente, se computa la correlación entre cada variable independiente $X_i$ con el residuo y se incorpora al modelo la variable con la mayor correlación absoluta. El proceso se repite esta vez con las predicciones del nuevo modelo y se continua hasta alcanzar una desempeño deseado o un número determinado de variables. Este método fue utilizado satisfactoriamente en investigaciones previas @BONANSEA2019102265.\n\n![Fig. 1: Matriz de correlación entre las distintas bandas.](img/heatmap.svg){width=80%}\n\nUna herramienta útil para ayudar en la selección de variables es una matriz de correlación. Dos variables prefectamente correlacionadas resultan redundantes en el sentido de que añadir ambas no aporta información adicional. Sin embargo, una correlación muy alta entre variables (o anti-correlación) no significa ausencia de complementariedad.\n\n### Generación de características lineales y no lineales\n\nIncluir nuevas variables a partir de las originales, como productos, cocientes o transformaciones no lineales (por ejemplo, logaritmos, o raíces cuadradas) permite capturar relaciones más complejas entre las variables independientes y la variable objetivo. Por ejemplo, si se dispone de datos espectrales, pueden construirse razones entre bandas (band ratios) o índices espectrales que resalten ciertas propiedades físicas del fenómeno estudiado. Estas nuevas características permiten al modelo lineal aproximar mejor la relación entre los datos y la salida, especialmente cuando la relación real no es perfectamente lineal.\n\n### Métricas de desempeño\n\nLas métricas de desempeño permiten cuantificar qué tan bien un modelo se ajusta a los datos y predice resultados. Algunas métricas evalúan la calidad del ajuste, otras penalizan la complejidad y algunas miden directamente el error de predicción.\n\nEl **Coeficiente de Determinación Ajustado $R^2-ADJ$** es una variante de R² que corrige la tendencia de este último a aumentar al añadir más variables al modelo, incluso si no aportan mejora real. Mientras que el R² tradicional mide la proporción de variabilidad de la variable dependiente explicada por el modelo, el ADJ-R²penaliza la inclusión de predictores irrelevantes, ajustando el valor según el número de observaciones y el número de variables independientes. Esto lo hace más útil para comparar modelos con distinto número de predictores, evitando la falsa impresión de mejora solo por complejidad adicional.\n\nEl **Criterio de Información de Akaike (AIC)** es una métrica utilizada para comparar modelos estadísticos en términos de ajuste y complejidad. Se basa en la teoría de la entropía y busca identificar el modelo que mejor explica los datos con el menor número posible de parámetros. Un valor de AIC más bajo indica un mejor equilibrio entre ajuste y simplicidad. La fórmula general es:\n\n$$AIC = 2k - 2 ln(L)$$\n\ndonde $k$ es el número de parámetros estimados en el modelo y $L$ es el valor máximo de la función de verosimilitud. A diferencia del ADJ-R² el AIC no tiene un valor máximo fijo y es más útil cuando se comparan múltiples modelos candidatos sobre el mismo conjunto de datos.\n\nEl **Error Cuadrático Medio (MSE)** mide el promedio de los cuadrados de las diferencias entre los valores observados y los predichos por el modelo. Es una métrica sensible a errores grandes, ya que los eleva al cuadrado, y por eso penaliza más las predicciones alejadas de la realidad. Su fórmula es:\n\n$$\\text{MSE} = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2$$\n\ndonde $y_i$ y son $\\hat{y}_i$ los valores reales y los valores predichos. Un MSE más bajo indica un mejor desempeño del modelo, pero su escala depende de la magnitud de la variable objetivo, por lo que no siempre es directamente interpretable sin contexto.\n\n## Índices espectrales\nLos índices espectrales son combinaciones matemáticas de reflectancias en distintas bandas del espectro electromagnético obtenidas por sensores remotos, como satélites o drones. Estos índices realzan ciertas características o propiedades de la superficie observada, facilitando la identificación y monitoreo de elementos como vegetación, agua, suelo o áreas urbanas. Al reducir la información a una sola variable combinada, permiten detectar cambios y evaluar condiciones ambientales con mayor precisión que el análisis de bandas individuales.\n\n### NDWI\nEl Índice de Diferencia Normalizada del Agua (NDWI) es un índice espectral diseñado para resaltar la presencia y extensión de cuerpos de agua en imágenes satelitales. Se calcula utilizando reflectancias en bandas específicas del verde y el infrarrojo cercano, y su fórmula clásica es:\n\n$$NDWI = \\frac{R_{\\text{verde}} - R_{\\text{NIR}}}{R_{\\text{verde}} + R_{\\text{NIR}}}$$\n\ndonde $R_{verde} es la reflectancia en la banda verde y $R_{NIR}$ la reflectancia en la banda del infrarrojo cercano. Valores altos de NDWI indican presencia probable de agua, ya que el agua absorbe fuertemente en el NIR y refleja más en el verde.\n\n# Regresión Lineal\n\nLa construcción del modelo se lleva a cabo utilizando la versión de Python 3.12 y las librerías previamente especificadas, detallando la función de cada pieza de código, observaciones, avances y descubrimientos.\n\n## Librerías\n\nPara regresión lineal se usan principalmente las librerías de Python *numpy*, *pandas* y *Scikit-learn*.\n\n- **Scikit-learn**: está en el corazón de las operaciones de ciencias de datos en Python. Ofrece módulos para procesamiento de datos, aprendizaje supervisado y no supervisado, selección y validación de modelos, y métricas de error.\n- **Pandas**: especializada en la manipulación y el análisis de datos. Ofrece estructuras de datos y operaciones para manipular tablas numéricas y series temporales.\n- **NumPy**: provee al usuario con arreglos multidimensionales, junto a un gran conjunto de funciones para operar en estos.\n\n## Lectura de datos\n\nPara la carga, lectura y manipulación de la información la librería *Pandas* permite convertir un archivo .csv en un *DataFrame*, estructura de datos que facilita la manipulación de estos. El fragmento de código siguiente agrupa los valores de $SDD$ con los valores de reflectancia a diferentes longitudes de onda para los cuales coinciden fecha, latitud y longitud y crea un nuevo *DataFrame*.\n\n::: {#b3f1a442 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\n\n# Rutas a los archivos CSV\narchivo_reflectancias = \"datos\\\\base_de_datos_gis.csv\"  # contiene: fecha,punto,pixel,banda,reflect,longitud,latitud\narchivo_parametros = \"datos\\\\base_de_datos_lab.csv\"     # contiene: fecha,longitud,latitud,param,valor\n\n# Leer los archivos\ndf_reflect = pd.read_csv(archivo_reflectancias)\ndf_param = pd.read_csv(archivo_parametros)\n\n# Filtrar los parámetros \"secchi\"\ndf_secchi = df_param[df_param[\"param\"].str.lower() == \"secchi\"]\n\n# Merge por fecha y coordenadas\nmerged = pd.merge(\n    df_secchi,\n    df_reflect,\n    on=[\"fecha\", \"latitud\", \"longitud\"],\n    how=\"inner\"\n)\n\n# Pivotear la tabla para poner bandas como columnas\ntabla_final = merged.pivot_table(\n    index=[\"param\", \"fecha\", \"longitud\", \"latitud\", \"valor\"], \n    columns=\"banda\",\n    values=\"reflect\"\n).reset_index()\n\n# Reordenar columnas: param | B01 | B02 | ... | B8A\nbandas = ['B01', 'B02', 'B03', 'B04', 'B05', 'B06', 'B07', 'B08', 'B11', 'B12', 'B8A']\ncolumnas_finales = ['valor'] + bandas\n\n# Crear Tabla final\ndf = tabla_final[columnas_finales]\n\n# Guardar excel para pruebas finales\nsalida_excel = \".//datos//tabla_final.xlsx\"\ndf.to_excel(salida_excel, index=False)\n```\n:::\n\n\nEl *DataFrame* obtenido se asemeja a la siguiente tabla:\n\n| $\\mathrm{SDD}$  | $\\mathrm{B01}$  | $\\mathrm{B02}$  | $\\cdots$  | $\\mathrm{B12}$  | $\\mathrm{B8A}$  |\n| :--------------:| :--------------:| :--------------:| :--------:| :--------------:| :--------------:|\n| 10              | 0,1728          | 0,1754          | $\\cdots$  | 0,1404          | 0,1869          |\n| 15              | 0,1497          | 0,17022         | $\\cdots$  | 0,1113          | 0,1567          |\n| $\\vdots$        | $\\vdots$        | $\\vdots$        | $\\cdots$  | $\\vdots$        | $\\vdots$        |\n| 125             | 0,1571          | 0,1563          | $\\cdots$  | 0,1419          | 0,1436          |scr\n| 135             | 0,1503          | 0,1591          | $\\cdots$  | 0,1420          | 0,1454          |\n\n: Tabla 3: DataFrame de los datos recolectados. {.striped .hover .responsive}\n\n## Análisis de los datos\n\nLa relación no lineal entre la penetración de la luz y la profundidad de disco de Secchi fue ya descrita por diversos autores que hallan una mejor descripción de esta como una de tipo logaritmica @modisComparison. Se verifica este comportamiento con las bandas B04, B05 y B06:\n\n::: {#06a491cc .cell execution_count=2}\n\n::: {.cell-output .cell-output-display}\n![](desarrollo_files/figure-html/cell-3-output-1.png){width=758 height=662}\n:::\n:::\n\n\n## Desarrollo del modelo\n\n\n\nPara el desarrollo del modelo se implementó la clase ```RegresionLineal```, que contiene el código necesario para la construcción y selección de variables así como para la validación cruzada del modelo. La misma requiere unicamente de los arrays correspondientes a la variable objetivo y a las características con las que estimarla. El script se encuentra disponible [acá](https://github.com/mauri491/sitio_secchi/blob/main/scripts/regresion.py).\n\nSe realiza la búsqueda de ecuaciones utilizando los valores de reflectancia corregidos por SEN2COR y por ACOLITE de manera separada.\n\n### Corrección por SEN2COR\n\nLa implementación del método sepwise forward selection permite evaluar la adición de variables al modelo predictivo en una instancia inicial donde no se general características adicionales. Los resultados de cada paso se encuentran resumidos en la siguiente tabla:\n\n::: {#399000db .cell execution_count=4}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Paso</th>\n      <th>Variable</th>\n      <th>R²</th>\n      <th>ADJ-R²</th>\n      <th>RMSE</th>\n      <th>AIC</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>Ninguna</td>\n      <td>-0.0263</td>\n      <td>-0.0263</td>\n      <td>44.7372</td>\n      <td>119.03</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>B05</td>\n      <td>0.2761</td>\n      <td>0.2221</td>\n      <td>37.6319</td>\n      <td>113.56</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>B02</td>\n      <td>0.7158</td>\n      <td>0.6701</td>\n      <td>23.2318</td>\n      <td>99.69</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>B08</td>\n      <td>0.7614</td>\n      <td>0.6989</td>\n      <td>21.3544</td>\n      <td>99.41</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>B03</td>\n      <td>0.8165</td>\n      <td>0.7459</td>\n      <td>18.7613</td>\n      <td>97.38</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td>B04</td>\n      <td>0.8296</td>\n      <td>0.7383</td>\n      <td>17.9258</td>\n      <td>97.47</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\nLa combinación de B05, B02 y B08 resulta en el mejor ajuste para valores mínimos de RMSE y AIC.\n\nHaciendo uso de la relación logaritmica entre la profundidad de disco y la penetración de la luz descrita y probada previamente se obtiene un modelo con una notable mejoría:\n\n::: {#21b5a6fc .cell execution_count=5}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Paso</th>\n      <th>Variable</th>\n      <th>R²</th>\n      <th>ADJ-R²</th>\n      <th>RMSE</th>\n      <th>AIC</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>Ninguna</td>\n      <td>-0.1888</td>\n      <td>-0.1888</td>\n      <td>48.1871</td>\n      <td>121.19</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>B05</td>\n      <td>0.2949</td>\n      <td>0.2421</td>\n      <td>36.9801</td>\n      <td>112.79</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>B02</td>\n      <td>0.8333</td>\n      <td>0.8063</td>\n      <td>17.7159</td>\n      <td>91.89</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>B08</td>\n      <td>0.8379</td>\n      <td>0.7950</td>\n      <td>17.4478</td>\n      <td>93.32</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>B11</td>\n      <td>0.8519</td>\n      <td>0.7944</td>\n      <td>16.5047</td>\n      <td>93.56</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td>B07</td>\n      <td>0.8549</td>\n      <td>0.7768</td>\n      <td>16.5084</td>\n      <td>95.74</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\nLa mejoría se extiende hasta la adición de la variable B07, después de la cual hay una ligera disminución de R²-ADJ, pero no lo suficientemente significativa como para tratarse de un caso de sobreajuste considerable.\n\nLa aplicación del logaritmo puede extenderse a las variables mismas, resultando en un modelo predictivo mucho más certero con una menor cantidad de variables:\n\n::: {#bb7928a3 .cell execution_count=6}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Paso</th>\n      <th>Variable</th>\n      <th>R²</th>\n      <th>ADJ-R²</th>\n      <th>RMSE</th>\n      <th>AIC</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>Ninguna</td>\n      <td>-0.1888</td>\n      <td>-0.1888</td>\n      <td>48.1871</td>\n      <td>121.19</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>log(B05)</td>\n      <td>0.4339</td>\n      <td>0.3916</td>\n      <td>32.8131</td>\n      <td>108.64</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>log(B02)</td>\n      <td>0.8834</td>\n      <td>0.8644</td>\n      <td>15.0118</td>\n      <td>87.21</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>B06</td>\n      <td>0.8934</td>\n      <td>0.8651</td>\n      <td>14.3537</td>\n      <td>87.65</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>B08</td>\n      <td>0.9014</td>\n      <td>0.8631</td>\n      <td>13.6956</td>\n      <td>88.17</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td>B12</td>\n      <td>0.9093</td>\n      <td>0.8606</td>\n      <td>13.0846</td>\n      <td>88.57</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\nLa combinación de log(B05) y B02 resulta prometedora: el valor de AIC es mínimo, el RMSE es bajo, y el R² alto. Los coeficientes y ordenada de la ecuación resultante son:\n\n\n\n::: {#65837f86 .cell execution_count=8}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Paso</th>\n      <th>Variable</th>\n      <th>R²</th>\n      <th>ADJ-R²</th>\n      <th>RMSE</th>\n      <th>AIC</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>Ninguna</td>\n      <td>-0.1888</td>\n      <td>-0.1888</td>\n      <td>48.1871</td>\n      <td>121.19</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>log(B05)</td>\n      <td>0.4339</td>\n      <td>0.3916</td>\n      <td>32.8131</td>\n      <td>108.64</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>log(B02)</td>\n      <td>0.8834</td>\n      <td>0.8644</td>\n      <td>15.0118</td>\n      <td>87.21</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\nLos coeficientes y ordenada resultantes de considerar a las primeras dos variables son:\n\n::: {#34e84e93 .cell execution_count=9}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Variable</th>\n      <th>Coeficiente</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>log(B05)</td>\n      <td>-12.260673</td>\n    </tr>\n    <tr>\n      <td>log(B02)</td>\n      <td>13.030511</td>\n    </tr>\n    <tr>\n      <td>Ordenada</td>\n      <td>5.275337</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\nEl uso de cocientes entre las variables otorga una cantidad mucho más extensiva de predictores, observamos que de considerar a estos junto con las variables linealizadas, estos predominan como mejores contribuyentes a la mejora de la predicción:\n\n::: {#daaf63ca .cell execution_count=10}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Paso</th>\n      <th>Variable</th>\n      <th>R²</th>\n      <th>ADJ-R²</th>\n      <th>RMSE</th>\n      <th>AIC</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>Ninguna</td>\n      <td>-0.1888</td>\n      <td>-0.1888</td>\n      <td>48.1871</td>\n      <td>121.19</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>B05/B02</td>\n      <td>0.8822</td>\n      <td>0.8734</td>\n      <td>15.0707</td>\n      <td>84.77</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>log(B01)</td>\n      <td>0.8966</td>\n      <td>0.8798</td>\n      <td>14.0689</td>\n      <td>84.36</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>B08/B06</td>\n      <td>0.9091</td>\n      <td>0.8850</td>\n      <td>13.1732</td>\n      <td>84.66</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>B8A/B11</td>\n      <td>0.9100</td>\n      <td>0.8750</td>\n      <td>13.0816</td>\n      <td>86.29</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td>B07/B11</td>\n      <td>0.9087</td>\n      <td>0.8596</td>\n      <td>13.1518</td>\n      <td>88.25</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\nLos coeficientes y ordenada resultantes de considerar a las primeras dos variables son:\n\n\n\n::: {#2b868eaf .cell execution_count=12}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Variable</th>\n      <th>Coeficiente</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>B05/B02</td>\n      <td>-4.268558</td>\n    </tr>\n    <tr>\n      <td>log(B01)</td>\n      <td>0.643369</td>\n    </tr>\n    <tr>\n      <td>Ordenada</td>\n      <td>9.430494</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\n### Corrección por ACOLITE\n\nSe repite el proceso que con los datos corregidos por el algoritmo SEN2COR. Se menciona que en la lectura y tratamiento de datos se descartaron los puntos para los cuales los valores de reflectancia eran negativos luego de la corrección.\n\n\n\nPartimos de haber hallado que la aplicación del logaritmo a la profundidad de disco resulta en un mejor ajuste. En relación a los valores corregidos por ACOLITE esto devuelve los siguientes resultados:\n\n::: {#826af9bd .cell execution_count=14}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Paso</th>\n      <th>Variable</th>\n      <th>R²</th>\n      <th>ADJ-R²</th>\n      <th>RMSE</th>\n      <th>AIC</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>Ninguna</td>\n      <td>-0.2303</td>\n      <td>-0.2303</td>\n      <td>47.8282</td>\n      <td>59.46</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>B05</td>\n      <td>0.1189</td>\n      <td>-0.0378</td>\n      <td>38.8925</td>\n      <td>56.79</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>B02</td>\n      <td>0.6160</td>\n      <td>0.4521</td>\n      <td>27.3299</td>\n      <td>51.54</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>B08</td>\n      <td>0.7201</td>\n      <td>0.4925</td>\n      <td>23.1573</td>\n      <td>51.70</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>B03</td>\n      <td>0.8162</td>\n      <td>0.5245</td>\n      <td>16.6068</td>\n      <td>48.02</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td>B06</td>\n      <td>0.8334</td>\n      <td>0.2594</td>\n      <td>16.2201</td>\n      <td>49.84</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\nObservamos que para las mismas combinaciones los valores de R² y R²-ADJ aumentaron significativamente respecto a aquellos con la corrección por SEN2COR.\n\nPara una relación doblemente logarítimica, obtenemos lo siguiente:\n\n::: {#1c692087 .cell execution_count=15}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Paso</th>\n      <th>Variable</th>\n      <th>R²</th>\n      <th>ADJ-R²</th>\n      <th>RMSE</th>\n      <th>AIC</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>Ninguna</td>\n      <td>-0.2303</td>\n      <td>-0.2303</td>\n      <td>47.8282</td>\n      <td>59.46</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>log(B05)</td>\n      <td>0.3287</td>\n      <td>0.2083</td>\n      <td>28.9200</td>\n      <td>52.62</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>log(B02)</td>\n      <td>0.6888</td>\n      <td>0.5550</td>\n      <td>21.0484</td>\n      <td>49.21</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>B01</td>\n      <td>0.7729</td>\n      <td>0.5845</td>\n      <td>18.4856</td>\n      <td>48.91</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>log(B08)</td>\n      <td>0.8185</td>\n      <td>0.5269</td>\n      <td>15.6606</td>\n      <td>48.45</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td>B06</td>\n      <td>0.8315</td>\n      <td>0.2347</td>\n      <td>15.0506</td>\n      <td>50.27</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\n\n\n::: {#7b895468 .cell execution_count=17}\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Variable</th>\n      <th>Coeficiente</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>log(B05)</td>\n      <td>-5.058134</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>log(B02)</td>\n      <td>6.861923</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>B01</td>\n      <td>-18.872053</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Ordenada</td>\n      <td>7.577205</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nDonde esta vez se ve una desmejora respecto al modelo corregido por SEN2COR para un modelo de dos variables logarítimicas.\n\nLa incorporación de cocientes al abanico de variables devuelve las siguientes métricas:\n\n::: {#e97462de .cell execution_count=18}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Paso</th>\n      <th>Variable</th>\n      <th>R²</th>\n      <th>ADJ-R²</th>\n      <th>RMSE</th>\n      <th>AIC</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>Ninguna</td>\n      <td>-0.2303</td>\n      <td>-0.2303</td>\n      <td>47.8282</td>\n      <td>59.46</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>B04/B02</td>\n      <td>0.7325</td>\n      <td>0.6853</td>\n      <td>20.3765</td>\n      <td>47.21</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>B04/B01</td>\n      <td>0.7795</td>\n      <td>0.6848</td>\n      <td>19.1909</td>\n      <td>48.01</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>B07/B06</td>\n      <td>0.8216</td>\n      <td>0.6737</td>\n      <td>15.8882</td>\n      <td>47.67</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>B08</td>\n      <td>0.8167</td>\n      <td>0.5294</td>\n      <td>16.0595</td>\n      <td>49.33</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td>B11/B05</td>\n      <td>0.8592</td>\n      <td>0.3978</td>\n      <td>13.5437</td>\n      <td>48.60</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\n\n\n::: {#b51b2db6 .cell execution_count=20}\n\n::: {.cell-output .cell-output-display execution_count=20}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Variable</th>\n      <th>Coeficiente</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>B04/B02</td>\n      <td>-1.582140</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Ordenada</td>\n      <td>6.402011</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNuevamente, se ve una desmejora respecto al modelo corregido por SEN2COR. El número de variables se reduce a una.\n\n## Ecuaciones halladas\n\nEl par de mejores ecuaciones halladas para cada algoritmo de corrección utilizando la transformación logarítmica fueron las siguientes:\n$$ log(SDD)_{SEN2COR} = -12.26 \\cdot log(B05) + 13.03 \\cdot log(B02) + 5.27 $$\n\n$$ log(SDD)_{ACOLITE} = -5.06 \\cdot log(B05) + 6.86 \\cdot log(B02) -18.87 \\cdot B01 $$\n\nSus ajustes se visualizan de la siguiente manera:\n\n::: {#9800df67 .cell .styled-output execution_count=21}\n\n::: {.cell-output .cell-output-display}\n![](desarrollo_files/figure-html/cell-22-output-1.png){width=742 height=376}\n:::\n:::\n\n\nEl par de mejores ecuaciones halladas para cada algoritmo utilizando cocientes entre las variables es:\n\n$$ log(SDD)_{SEN2COR} = -4.27\\frac{B05}{B02} + 0.64\\cdot log(B01)+ 9.43 $$\n\n$$ log(SDD)_{ACOLITE} = -1.58\\frac{B04}{B02} + 6.40 $$\n\nSus ajustes se visualizan de la siguiente manera:\n\n::: {#5b2fde4d .cell .styled-output execution_count=22}\n\n::: {.cell-output .cell-output-display}\n![](desarrollo_files/figure-html/cell-23-output-1.png){width=742 height=376}\n:::\n:::\n\n\nObservamos que la utilización del algoritmo de ACOLITE para la corrección atmosférica ocasiona una desmejora en la estimación.\n\n## Mapas de la estimación\n\nLos mapas generados para cada fecha corresponden al recorte del área de interés del producto satelital corregido por ACOLITE.\n\n\n\n::: {.panel-tabset}\n## 06/09/25\n\n::: {#4a57f811 .cell .styled-output execution_count=24}\n\n::: {.cell-output .cell-output-display}\n![](desarrollo_files/figure-html/cell-25-output-1.png){width=1132 height=365}\n:::\n:::\n\n\n## 16/12/24\n\n::: {#f0ba7aef .cell .styled-output execution_count=25}\n\n::: {.cell-output .cell-output-display}\n![](desarrollo_files/figure-html/cell-26-output-1.png){width=1132 height=365}\n:::\n:::\n\n\n## 30/05/24\n\n::: {#d76bfae4 .cell .styled-output execution_count=26}\n\n::: {.cell-output .cell-output-display}\n![](desarrollo_files/figure-html/cell-27-output-1.png){width=1137 height=365}\n:::\n:::\n\n\n## 20/05/24\n\n::: {#816577c7 .cell .styled-output execution_count=27}\n\n::: {.cell-output .cell-output-display}\n![](desarrollo_files/figure-html/cell-28-output-1.png){width=1137 height=365}\n:::\n:::\n\n\n## 12/12/23\n\n::: {#f598c5e2 .cell .styled-output execution_count=28}\n\n::: {.cell-output .cell-output-display}\n![](desarrollo_files/figure-html/cell-29-output-1.png){width=1132 height=365}\n:::\n:::\n\n\n## 11/05/23\n\n::: {#458b90f1 .cell .styled-output execution_count=29}\n\n::: {.cell-output .cell-output-display}\n![](desarrollo_files/figure-html/cell-30-output-1.png){width=1132 height=365}\n:::\n:::\n\n\n:::\n\n# Métodos de aprendizaje automático\n\nEn esta sección se emplean modelos de aprendizaje automático con el objetivo de estimar la profundidad del disco de Secchi a partir de variables predictoras derivadas de la reflectancia satelital. Estos modelos permiten identificar relaciones no lineales y aprovechar la información multiespectral de forma más eficiente que los métodos lineales tradicionales. En particular, se evalúan distintos algoritmos y configuraciones de hiperparámetros para optimizar la capacidad de predicción y analizar la contribución relativa de cada variable a la estimación de la transparencia del agua.\n\n## Random Forest\n\nRandom Forest es un algoritmo de aprendizaje automático basado en un conjunto de árboles de decisión entrenados con muestras y variables aleatorias. La combinación de múltiples árboles reduce la varianza y mejora la capacidad de generalización del modelo. Es robusto frente al sobreajuste y adecuado para capturar relaciones no lineales entre las variables.\n\n### Hiperparámetros\n\nLos hiperparámetros son valores que se definen antes del entrenamiento de un modelo y controlan cómo aprende. Ajustarlos correctamente permite mejorar el rendimiento y la capacidad de generalización del modelo.\n\n- ```n_estimators``` es el número total de árboles que se crearán en el bosque aleatorio. Cada árbol se entrena con una muestra distinta de los datos (si bootstrap=True) y sus predicciones se promedian. Aumentar este número hace que el modelo sea más estable y consistente, reduciendo la varianza y mejorando la precisión. Sin embargo, también incrementa el tiempo de entrenamiento y el uso de memoria, por lo que hay que buscar un equilibrio.\n\n- ```max_depth``` determina la cantidad máxima de niveles que puede tener cada árbol, es decir, cuántas divisiones sucesivas puede hacer desde la raíz hasta una hoja. Cuanto más profundo sea un árbol, más patrones complejos puede aprender, pero también corre el riesgo de memorizar el ruido de los datos (sobreajuste). Por el contrario, limitar la profundidad hace que los árboles sean más simples y generalicen mejor, aunque podrían no capturar todas las relaciones presentes en los datos.\n\n- ```min_samples_split``` indica el número mínimo de muestras necesarias para dividir un nodo en dos ramas. Este parámetro evita que el árbol realice divisiones basadas en muy pocos datos, que podrían ser poco representativos. Valores pequeños permiten divisiones frecuentes, generando árboles más complejos y propensos al sobreajuste, mientras que valores mayores producen divisiones más conservadoras y árboles más suaves que generalizan mejor.\n\n- ```min_samples_leaf``` establece el mínimo de muestras que debe contener una hoja, es decir, un nodo terminal del árbol. Si se permite una sola muestra por hoja, el árbol puede memorizar los datos y generar predicciones muy específicas pero poco generalizables. Aumentar este valor hace que cada hoja represente un promedio de varias observaciones, produciendo predicciones más estables y menos sensibles al ruido.\n\n- ```max_features``` determina cuántas variables se consideran al buscar la mejor división en cada nodo. Limitar la cantidad de features introduce aleatoriedad en cada árbol, lo que reduce la correlación entre ellos y mejora la generalización del bosque. Por ejemplo, \"sqrt\" utiliza la raíz cuadrada del total de variables y \"log2\" utiliza el logaritmo base 2 del total de variables. La diferencia es sutil pero importante: \"log2\" suele considerar menos variables en cada división, aumentando la diversidad entre árboles, mientras que \"sqrt\" toma un número ligeramente mayor, equilibrando diversidad y cantidad de información.\n\n- ```bootstrap```\n indica si cada árbol se entrena con una muestra aleatoria con reemplazo del conjunto total de datos. Si es True, cada árbol ve datos diferentes, lo que genera más diversidad entre árboles y mejora la capacidad de generalización. Si es False, todos los árboles utilizan el mismo conjunto, lo que puede hacerlos más parecidos entre sí y aumentar la posibilidad de sobreajuste. Además, usar bootstrap permite calcular errores de tipo “out-of-bag” para evaluar el modelo sin necesidad de un conjunto de validación separado.\n\n### Resultados\n\n![](modelos_ml\\rf_251014_0.9423_0.8823.png)\n\nEl modelo Random Forest mostró un buen nivel de ajuste y capacidad predictiva, capturando adecuadamente las relaciones entre variables. Sin embargo, presentó un RMSE más alto en comparación con los modelos lineales, lo que indica mayor dispersión en las predicciones y una menor precisión promedio pese a su buen desempeño general. La importancia de cada variable fue la siguiente:\n\n![](modelos_ml\\rf_importancia_251014.png)\n\nLas bandas B04 y B04 predominan en el ranking, esto puede deberse a que las bandas Red y Red Edge (B05–B06-B07) se ubican justo en la transición entre el rojo y el infrarrojo cercano, donde la reflectancia del agua cambia mucho con la concentración de sedimentos. Esto las hace excelentes indicadores de la turbidez y material particulado suspendido.\n\nCon el objetivo de mejorar el desempeño de los modelos, se incorporaron cocientes entre variables como nuevas características predictoras. Estas relaciones permiten resaltar contrastes espectrales y capturar patrones relativos entre bandas, lo que puede aumentar la sensibilidad del modelo frente a variaciones en la transparencia del agua y mejorar la estimación.\n\n![](modelos_ml\\rf_ratios_251014_0.9876_0.9295.png)\n\nAl introducir los cocientes entre variables como nuevas características, se observa una mejora notable en el desempeño de los modelos. En particular, el RMSE se redujo hasta menos de la mitad, indicando predicciones más precisas y consistentes\n\n![](modelos_ml\\rf_importancia_ratios_251014.png)\n\n## XGBoost\n\nXGBoost (Extreme Gradient Boosting) es un método de boosting que construye árboles de manera secuencial, donde cada uno corrige los errores del anterior. Incorpora técnicas de regularización y optimización que aumentan la precisión y evitan el sobreajuste, ofreciendo un excelente desempeño en tareas de regresión y clasificación.\n\n### Hiperparámetros\n\nAdemás de los hiperparámetros ```n_estimators``` y ```max_depth``` ya vistos para Random Forest, XGBoost cuenta con los siguientes hiperparámetros:\n\n- ```learning_rate``` controla cuánto contribuye cada árbol nuevo a la predicción total. Valores bajos (por ejemplo, 0.05) hacen que el modelo aprenda más despacio y con mayor precisión, requiriendo más árboles (n_estimators) para converger. Valores altos aceleran el aprendizaje, pero pueden provocar sobreajuste si los árboles son profundos o abundantes.\n\n- ```subsample``` indica la fracción de muestras de entrenamiento que se usan para construir cada árbol. Un valor menor que 1 introduce aleatoriedad, lo que reduce la correlación entre árboles y mejora la generalización, pero demasiado bajo puede hacer que el modelo no aprenda bien. Un valor de 1 significa que todos los datos se usan en cada árbol, maximizando ajuste pero con menor diversidad.\n\n- ```colsample_bytree``` define la fracción de variables (features) consideradas al entrenar cada árbol. Limitar las columnas aumenta la aleatoriedad entre árboles, reduciendo la correlación y el sobreajuste. Por ejemplo, 0.8 significa que cada árbol ve solo el 80% de las variables disponibles.\n\n- ```gamma``` es el mínimo incremento en la función de pérdida requerido para realizar una división adicional en un nodo. Valores mayores hacen que el árbol sea más conservador, evitando divisiones que aporten poca mejora en la predicción, lo que ayuda a reducir sobreajuste.\n\n- ```reg_alpha``` es la penalización de tipo L1 sobre los pesos de los árboles. Ayuda a reducir la complejidad del modelo y puede forzar algunos pesos a cero, promoviendo sparsity y simplificación. Esto es útil si hay muchas variables poco relevantes.\n\n- ```reg_lambda``` es la penalización de tipo L2 sobre los pesos de los árboles. Contrarresta valores extremos y ayuda a estabilizar el modelo, evitando que algunos árboles dominen la predicción y reduciendo el riesgo de sobreajuste.\n\n### Resultados\n\n![](modelos_ml\\xgb_251014_0.9761_0.8636.png)\n\nEl modelo XGBoost demuestra desde un inicio un poder predictivo mayor al de Random Forest y a su vez una dispersión mucho menor en las predicciones.\n\n![](modelos_ml\\xgb_importancia_251014.png)\n\nNuevamente se repite la predominancia de las bandas B04 y B05 en el ranking.\n\n![](modelos_ml\\xgb_ratios_251014_0.9909_0.9487.png)\n\nSe observa que la incorporación de cocientes incrementa considerablemente el poder predictivo, a la vez que el RMSE disminuye a valor comparables con el mejor de los valores lineales previamente obtenidos.\n\n![](modelos_ml\\xgb_importancia_ratios_251014.png)\n\n",
    "supporting": [
      "desarrollo_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}